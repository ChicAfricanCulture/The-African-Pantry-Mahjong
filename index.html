<!-- /index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The African Pantry Mahjong</title>

  <meta property="og:title" content="The African Pantry Mahjong" />
  <meta property="og:description" content="Match ingredients, discover recipes, and explore African foodways." />
  <meta property="og:url" content="https://chicafricanculture.github.io/The-African-Pantry-Mahjong/" />
  <meta property="og:type" content="website" />

  <style>
    :root{
      --bg1:#1a2a3a;
      --bg2:#0d1b2a;
      --panel: rgba(13, 27, 42, 0.92);
      --panel2: rgba(26, 42, 58, 0.80);
      --accent:#f9a826;
      --muted:#b8c7d6;
      --text:#e0e0e0;

      --tileA:#e8d0b0;
      --tileB:#b08968;
      --tileBorder:#c49a6c;
      --focus: #ffd18a;
    }

    *{ box-sizing:border-box; }
    body{
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      color: var(--text);
      min-height: 100vh;
      margin:0;
      padding:20px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display:flex;
      flex-direction:column;
      align-items:center;
    }

    .container{ width:100%; max-width:1200px; }

    header{
      text-align:center;
      margin-bottom:18px;
      padding:36px 20px;
      background: rgba(13, 27, 42, 0.95);
      border-radius:15px;
      box-shadow:0 8px 32px rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.10);
    }
    h1{
      margin:0 0 10px;
      font-size:2.35rem;
      color:var(--accent);
      text-shadow:2px 2px 4px rgba(0,0,0,0.5);
    }
    .subtitle{
      margin:0 auto;
      max-width:760px;
      color:var(--muted);
      font-size:1.05rem;
      line-height:1.5;
    }

    .archive-link{
      text-align:center;
      margin:0.5rem 0 1.25rem;
      color:var(--muted);
    }
    .archive-link a{
      color:var(--accent);
      text-decoration:none;
      font-weight:bold;
    }
    .archive-link a:hover{ text-decoration:underline; }

    .game-area{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:18px;
      align-items:start;
    }

    .board-container,.info-panel{
      background: var(--panel);
      border-radius:15px;
      padding:18px;
      box-shadow:0 8px 32px rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.10);
      overflow:hidden;
    }

    .level-indicator{
      background: var(--panel2);
      border:1px solid rgba(249,168,38,0.30);
      border-radius:10px;
      padding:12px 14px;
      text-align:center;
      margin-bottom:14px;
    }
    .level-text{
      color:var(--accent);
      font-weight:bold;
      letter-spacing:0.4px;
    }

    .mahjong-board{
      position:relative;
      width:100%;
      margin:0 auto;
      border-radius:12px;
      background: rgba(26,42,58,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      overflow:hidden;
      outline: none;
    }

    .tile{
      position:absolute;
      background: linear-gradient(145deg, var(--tileA), var(--tileB));
      border:3px solid var(--tileBorder);
      border-radius:12px;
      box-shadow:0 6px 14px rgba(0,0,0,0.55);
      display:flex;
      justify-content:center;
      align-items:center;
      cursor:pointer;
      user-select:none;
      transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
      padding:6px;
      overflow:hidden;
      outline: none;
    }

    .tile:focus-visible{
      box-shadow: 0 0 0 3px rgba(255, 209, 138, 0.45), 0 10px 18px rgba(0,0,0,0.65);
      border-color: var(--focus);
    }

    .tile:hover:not(.blocked){
      transform: translateY(-2px);
      border-color: var(--accent);
      box-shadow:0 10px 18px rgba(0,0,0,0.65);
    }
    .tile.selected{
      transform: translateY(-6px);
      border-color: var(--accent);
      box-shadow:0 0 18px rgba(249,168,38,0.55), 0 12px 22px rgba(0,0,0,0.65);
    }

    .tile.blocked{
      filter: grayscale(0.9) brightness(0.72);
      cursor:not-allowed;
    }

    /* no transparency: removed from DOM flow */
    .tile.matched{ display:none !important; }

    .tile img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.35));
      pointer-events: none;
    }

    .tile.wrong-match{
      animation: shake 0.35s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
      border-color:#ff4444 !important;
    }

    @keyframes shake {
      10%, 90% { transform: translate3d(-2px, 0, 0); }
      20%, 80% { transform: translate3d(4px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
      40%, 60% { transform: translate3d(8px, 0, 0); }
    }

    .info-panel{
      display:flex;
      flex-direction:column;
      gap:16px;
    }

    .stats{
      display:grid;
      grid-template-columns: repeat(4,1fr);
      gap:10px;
      background: var(--panel2);
      padding:14px;
      border-radius:10px;
    }
    .stat{ text-align:center; }
    .stat-value{ color:var(--accent); font-weight:bold; font-size:1.35rem; }
    .stat-label{ color:var(--muted); font-size:0.78rem; text-transform:uppercase; letter-spacing:0.5px; }

    .symbol-info{
      background: var(--panel2);
      padding:14px;
      border-radius:10px;
      min-height:120px;
    }
    .symbol-name{ color:var(--accent); font-weight:bold; font-size:1.25rem; margin-bottom:8px; }
    .symbol-meaning{ color:var(--muted); line-height:1.5; }

    .controls{ display:flex; flex-direction:column; gap:10px; }
    button{
      background: linear-gradient(135deg, var(--accent), #e8951e);
      color:#1a2a3a;
      border:none;
      padding:14px;
      border-radius:8px;
      font-weight:bold;
      cursor:pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, opacity 0.12s ease;
      font-size:1rem;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }
    button:hover:not(:disabled){
      transform: translateY(-2px);
      box-shadow:0 4px 12px rgba(249,168,38,0.40);
    }
    button:disabled{ opacity:0.45; cursor:not-allowed; }

    .shuffle-warning{
      color:#ff6b6b;
      font-size:0.9rem;
      text-align:center;
      font-weight:bold;
      min-height:1.1em;
      margin-top:-6px;
    }

    .proverb-message{
      position:fixed;
      top:50%;
      left:50%;
      transform: translate(-50%,-50%);
      background:#f9a826;
      color:#1a2a3a;
      padding:22px 28px;
      border-radius:15px;
      text-align:center;
      font-size:1.2rem;
      font-weight:bold;
      z-index:2000;
      box-shadow:0 10px 40px rgba(0,0,0,0.55);
      max-width:520px;
      border:2px solid #fff3e0;
    }

    .win-message{
      position:fixed;
      inset:0;
      background: rgba(13,27,42,0.98);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      text-align:center;
      z-index:2000;
      padding:20px;
    }
    .win-message h2{
      font-size:2.6rem;
      color:var(--accent);
      margin:0 0 14px;
      text-shadow:0 0 18px rgba(249,168,38,0.30);
    }
    .win-message p{
      font-size:1.2rem;
      max-width:720px;
      color:var(--text);
      margin:0 0 22px;
      line-height:1.5;
    }
    .win-message button{
      margin:8px;
      min-width:200px;
      font-size:1.05rem;
      padding:14px 26px;
    }
    .hidden{ display:none !important; }

    footer{
      margin-top:28px;
      text-align:center;
      color:#6a7a8a;
      font-size:0.9rem;
    }

    @media (max-width:1100px){
      .game-area{ grid-template-columns:1fr; }
    }
    @media (max-width:560px){
      .stats{ grid-template-columns: repeat(2,1fr); }
      h1{ font-size:2rem; }
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce){
      .tile, button { transition: none !important; }
      .tile.wrong-match { animation: none !important; }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>The African Pantry Mahjong</h1>
      <p class="subtitle">Match ingredients, discover recipes, and explore the rich foodways of the African continent.</p>
    </header>

    <p class="archive-link">
      Part of the <strong>African Foodways Archive</strong> ¬∑
      <a href="https://chicafricanculture.github.io/african-foodways-data/">Explore the Collection</a>
    </p>

    <div class="game-area">
      <div class="board-container">
        <div class="level-indicator">
          <span class="level-text">Level <span id="level">1</span> ¬∑ <span id="total-tiles">64</span> Ingredients</span>
        </div>

        <!-- aria-label helps screen readers; board itself is not focusable -->
        <div class="mahjong-board" id="board" aria-label="Mahjong board"></div>
      </div>

      <div class="info-panel">
        <div class="stats" aria-label="Game statistics">
          <div class="stat"><div class="stat-value" id="matches">0</div><div class="stat-label">Matches</div></div>
          <div class="stat"><div class="stat-value" id="remaining">64</div><div class="stat-label">Remaining</div></div>
          <div class="stat"><div class="stat-value" id="time">00:00</div><div class="stat-label">Time</div></div>
          <div class="stat"><div class="stat-value" id="shuffle-count">3</div><div class="stat-label">Shuffles</div></div>
        </div>

        <div class="symbol-info" aria-live="polite">
          <div class="symbol-name" id="symbol-name">Select a tile</div>
          <div class="symbol-meaning" id="symbol-meaning">Click any ingredient to learn about its place in African cooking</div>
        </div>

        <div class="controls">
          <button id="hint-btn">üîç Find Match</button>
          <button id="shuffle-btn">üîÑ Shuffle</button>
          <button id="reset-btn">üÜï New Game</button>
          <button id="sound-btn" aria-pressed="false">üîá Sound: Off</button>
        </div>

        <div class="shuffle-warning" id="shuffle-warning"></div>

        <div style="color: var(--muted); font-size: 0.92rem; line-height: 1.35;">
          <strong>Keyboard:</strong> Arrow keys to move ‚Ä¢ Enter/Space to select.
        </div>
      </div>
    </div>

    <footer>
      <p>African Foodways Archive ¬∑ Preserving culinary heritage through play</p>
    </footer>
  </div>

  <div class="win-message hidden" id="win-message" role="dialog" aria-modal="true" aria-label="Win message">
    <h2>üèÜ Pantry Mastered! üèÜ</h2>
    <p id="win-text">You've matched all the ingredients!</p>
    <button id="next-level-btn">‚¨ÜÔ∏è Next Level</button>
    <button id="play-again-btn">üîÑ Play Again</button>
  </div>

<script>
/** ==================== PROVERBS ==================== */
const proverbs = [
  "The one who eats alone cannot discuss the taste of the food with others.",
  "The firewood that cooks the food is the same one that burns the cook.",
  "Soup that is too hot makes one wait before eating.",
  "A full belly is the mother of all songs.",
  "You cannot taste honey without burning your tongue.",
  "If you want to eat a lot of food, don't wash your hands too clean.",
  "One cannot prepare soup without water.",
  "However long the night, the dawn will break.",
  "A single bracelet does not jingle.",
  "By the time the fool has learned the game, the players have dispersed.",
  "Patience can cook a stone.",
  "The best palm oil is squeezed by the thumb.",
  "However full the river, it still wants to grow."
];

const lossProverbs = [
  "The pot that boils too much loses its flavor.",
  "Even the best cook sometimes burns the stew.",
  "A bad cook blames his pots and pestle.",
  "When the cooking pot is empty, the fire feels ashamed.",
  "A fall is not a failure, but a failure to rise is.",
  "The elephant does not get tired of its trunk.",
  "The best fisherman sometimes comes home empty-handed."
];

/** ==================== FOOD SYMBOLS ==================== */
const foodSymbols = [
  { id: 1, name: "Baobab", meaning: "Baobab fruit - vitamin-rich powder for drinks, sauces, and porridges. The 'tree of life' provides food and medicine.", imageFile: "baobab.png" },
  { id: 2, name: "Bee", meaning: "Honey - natural sweetener in traditional cooking, used in teas, baked goods, and as a preservative. Symbolizes community and industry.", imageFile: "bee.png" },
  { id: 3, name: "Beer", meaning: "Traditional sorghum and millet beers - ceremonial and social drinks, often thicker than western beers and rich in B vitamins.", imageFile: "beer.png" },
  { id: 4, name: "Chef's Hands", meaning: "The skilled hands that prepare our meals - knowledge passed down through generations. Cooking is an art taught by mothers and grandmothers.", imageFile: "chef-hands.png" },
  { id: 5, name: "Cooking Spoon", meaning: "The wooden spoon that stirs communities together. Often carved from a single piece of wood and seasoned with decades of use.", imageFile: "cooking-spoon.png" },
  { id: 6, name: "Corn", meaning: "Maize - kenkey, ugali, sadza, and porridges. A staple grain introduced to Africa and now central to many cuisines.", imageFile: "corn.png" },
  { id: 7, name: "Cow", meaning: "Suya, rich stews, and traditional ceremonies. Cattle represent wealth and are often only slaughtered for special occasions.", imageFile: "cow.png" },
  { id: 8, name: "Crab", meaning: "Coastal soups and crab pepper soup. Fresh seafood is central to West and East African coastal cuisine.", imageFile: "crab.png" },
  { id: 9, name: "Egg", meaning: "Ghanaian egg stew, boiled eggs in puff-puff, and ceremonial dishes. Eggs symbolize fertility and new beginnings.", imageFile: "egg.png" },
  { id: 10, name: "Egusi", meaning: "Melon seeds - thickener for soups and stews. Ground egusi gives body and rich flavor to dishes across West Africa.", imageFile: "Egusi.png" },
  { id: 11, name: "Fire", meaning: "Traditional cooking methods and hearths. The three-stone fire is the original kitchen, gathering families for generations.", imageFile: "fire.png" },
  { id: 12, name: "Fish", meaning: "Grilled tilapia, fish pepper soups, dried and smoked fish. Preserving fish by smoking or drying is an ancient technique.", imageFile: "fish.png" },
  { id: 13, name: "Fishing", meaning: "River and coastal communities. Fishing villages have unique culinary traditions based on daily catches.", imageFile: "fishing.png" },
  { id: 14, name: "Fufu", meaning: "Pounded cassava and plantain - West Africa's signature swallow food. Made by pounding boiled cassava and plantain until smooth and elastic.", imageFile: "fufu.png" },
  { id: 15, name: "Goat", meaning: "Goat pepper soup, ceremonial dishes. Goat meat is lean and flavorful, often reserved for special guests and celebrations.", imageFile: "goat.png" },
  { id: 16, name: "Grain", meaning: "Millet, sorghum, teff - ancient grains. These drought-resistant grains have nourished Africans for thousands of years.", imageFile: "grain.png" },
  { id: 17, name: "Hibiscus", meaning: "Zobo drink, sorrel - refreshing beverages. Dried hibiscus flowers make a tart, cranberry-like drink enjoyed across the continent.", imageFile: "hibiscus.png" },
  { id: 18, name: "Maggi", meaning: "Essential seasoning in modern African cooking.", imageFile: "maggi.png" },
  { id: 19, name: "Mango", meaning: "Sweet tropical fruit - fresh, dried, or in chutneys.", imageFile: "Mango.png" },
  { id: 20, name: "Mortar", meaning: "Pounding fufu, grinding spices.", imageFile: "mortor.png" },
  { id: 21, name: "Palm Oil", meaning: "Banga soup, essential for stews.", imageFile: "palm-oil.png" },
  { id: 22, name: "Pepper", meaning: "Scotch bonnet, peri-peri, spice blends.", imageFile: "pepper.png" },
  { id: 23, name: "Plantain", meaning: "Kelewele, dodo, fried plantains.", imageFile: "plantain.png" },
  { id: 24, name: "Plate", meaning: "Communal dining and sharing meals.", imageFile: "plate.png" },
  { id: 25, name: "Pot", meaning: "One-pot cooking, communal meals.", imageFile: "pot.png" },
  { id: 26, name: "Rice", meaning: "Jollof, fried rice, coconut rice.", imageFile: "rice.png" },
  { id: 27, name: "Salt", meaning: "Preservation and flavor.", imageFile: "salt.png" },
  { id: 28, name: "Street Hawkers", meaning: "Mobile food vendors and street food culture.", imageFile: "street-hawkers.png" },
  { id: 29, name: "Vegetables", meaning: "Cassava leaves, bitterleaf, spinach.", imageFile: "vegetables.png" },
  { id: 30, name: "Water", meaning: "The foundation of all cooking.", imageFile: "water.png" },
  { id: 31, name: "Wood", meaning: "Fuel for traditional cooking fires.", imageFile: "wood.png" },
  { id: 32, name: "Yam", meaning: "Yam pottage (asaro), boiled yam with sauces.", imageFile: "yam.png" }
];

const dom = {
  board: document.getElementById('board'),
  matches: document.getElementById('matches'),
  remaining: document.getElementById('remaining'),
  time: document.getElementById('time'),
  level: document.getElementById('level'),
  total: document.getElementById('total-tiles'),
  name: document.getElementById('symbol-name'),
  meaning: document.getElementById('symbol-meaning'),
  hint: document.getElementById('hint-btn'),
  shuffle: document.getElementById('shuffle-btn'),
  reset: document.getElementById('reset-btn'),
  next: document.getElementById('next-level-btn'),
  again: document.getElementById('play-again-btn'),
  win: document.getElementById('win-message'),
  winText: document.getElementById('win-text'),
  shuffleCount: document.getElementById('shuffle-count'),
  shuffleWarning: document.getElementById('shuffle-warning'),
  soundBtn: document.getElementById('sound-btn')
};

const state = {
  tiles: [],
  selectedId: null,
  matches: 0,
  remaining: 64,
  level: 1,
  totalTiles: 64,
  shufflesRemaining: 3,
  startTime: null,
  timerInterval: null,
  elapsed: 0,
  layout: [],
  geom: { tileW: 70, tileH: 87, stepX: 55, stepY: 68, pad: 14, liftX: 10, liftY: 10, minX: 0, minY: 0 },
  // accessibility focus
  focusedTileId: null,
  // sound/haptics
  soundEnabled: false,
  audioCtx: null,
  reducedMotion: window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches
};

/** ==================== AUDIO (WebAudio, no external files) ==================== */
function ensureAudio(){
  if(!state.soundEnabled) return null;
  if(!state.audioCtx){
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if(!Ctx) return null;
    state.audioCtx = new Ctx();
  }
  if(state.audioCtx.state === 'suspended'){
    state.audioCtx.resume().catch(() => {});
  }
  return state.audioCtx;
}

function playTone({ type='sine', freq=440, durationMs=70, gain=0.06, attackMs=5, releaseMs=30 }){
  const ctx = ensureAudio();
  if(!ctx) return;

  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = type;
  o.frequency.value = freq;

  const now = ctx.currentTime;
  const dur = durationMs / 1000;

  g.gain.setValueAtTime(0.0001, now);
  g.gain.linearRampToValueAtTime(gain, now + attackMs/1000);
  g.gain.linearRampToValueAtTime(0.0001, now + dur + releaseMs/1000);

  o.connect(g);
  g.connect(ctx.destination);

  o.start(now);
  o.stop(now + dur + releaseMs/1000);
}

function soundClick(){
  playTone({ type:'sine', freq: 520, durationMs: 35, gain: 0.045, attackMs: 2, releaseMs: 18 });
  vibrate(10);
}

function soundMatch(){
  playTone({ type:'sine', freq: 660, durationMs: 70, gain: 0.06, attackMs: 3, releaseMs: 30 });
  setTimeout(() => playTone({ type:'sine', freq: 880, durationMs: 90, gain: 0.055, attackMs: 3, releaseMs: 40 }), 65);
  vibrate(25);
}

function soundWrong(){
  playTone({ type:'sawtooth', freq: 110, durationMs: 90, gain: 0.055, attackMs: 2, releaseMs: 40 });
  setTimeout(() => playTone({ type:'sawtooth', freq: 95, durationMs: 90, gain: 0.05, attackMs: 2, releaseMs: 40 }), 55);
  vibrate(40);
}

function vibrate(ms){
  if(!state.soundEnabled) return;
  if(typeof navigator !== 'undefined' && navigator.vibrate){
    navigator.vibrate(ms);
  }
}

function updateSoundButton(){
  dom.soundBtn.setAttribute('aria-pressed', String(state.soundEnabled));
  dom.soundBtn.textContent = state.soundEnabled ? 'üîä Sound: On' : 'üîá Sound: Off';
}

/** ==================== UTIL ==================== */
function shuffleInPlace(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}
function kpos(p){ return `${p.l}:${p.gx}:${p.gy}`; }

function showMsg(text){
  const existing=document.querySelector('.proverb-message');
  if(existing) existing.remove();
  const div=document.createElement('div');
  div.className='proverb-message';
  div.setAttribute('role', 'status');
  div.setAttribute('aria-live', 'polite');
  div.textContent=text;
  document.body.appendChild(div);
  setTimeout(()=>{ if(div.parentNode) div.remove(); }, 3200);
}

function showInfo(sym){
  dom.name.textContent = sym.name;
  dom.meaning.textContent = sym.meaning;
}

/** ==================== LAYOUT / WINNABLE ==================== */
function buildLayout64(){
  const layout = [];
  for(let gy=0; gy<4; gy++) for(let gx=0; gx<8; gx++) layout.push({ l:1, gx, gy });      // 32
  for(let gy=0; gy<3; gy++) for(let gx=1; gx<=6; gx++) layout.push({ l:2, gx, gy });     // 18 (50)
  for(let gy=0; gy<2; gy++) for(let gx=2; gx<=5; gx++) layout.push({ l:3, gx, gy });     // 8  (58)
  for(let gy=0; gy<3; gy++) for(let gx=3; gx<=4; gx++) layout.push({ l:4, gx, gy });     // 6  (64)
  if(layout.length !== 64) throw new Error(`Layout not 64: ${layout.length}`);
  return layout;
}

function computeFreeSet(occupied){
  const free = new Set();
  for(const key of occupied){
    const [l,gx,gy] = key.split(':').map(Number);

    let above=false;
    for(let hl=l+1; hl<=4; hl++){
      if(occupied.has(`${hl}:${gx}:${gy}`)){ above=true; break; }
    }
    if(above) continue;

    const left = occupied.has(`${l}:${gx-1}:${gy}`);
    const right = occupied.has(`${l}:${gx+1}:${gy}`);
    if(!left || !right) free.add(`${l}:${gx}:${gy}`);
  }
  return free;
}

function generateWinnable(){
  state.layout = buildLayout64();
  const remaining = new Set(state.layout.map(kpos));

  const symbols = [];
  for(const s of foodSymbols) symbols.push(s, s);
  shuffleInPlace(symbols);

  const assigned = new Map();
  const columnSymbol = new Map(); // gx:gy -> symbolId (prevents identical stacked)

  let idx=0;
  let guard=0;

  while(remaining.size){
    guard++; if(guard>7000) return generateWinnable();
    const freeKeys = Array.from(computeFreeSet(remaining));
    if(freeKeys.length < 2) return generateWinnable();

    const sym = symbols[idx];
    const symId = sym.id;

    shuffleInPlace(freeKeys);

    let a=null,b=null;
    for(let i=0;i<freeKeys.length;i++){
      const kA = freeKeys[i];
      const [,gxA,gyA] = kA.split(':');
      if(columnSymbol.get(`${gxA}:${gyA}`) === symId) continue;

      for(let j=i+1;j<freeKeys.length;j++){
        const kB = freeKeys[j];
        const [,gxB,gyB] = kB.split(':');
        if(columnSymbol.get(`${gxB}:${gyB}`) === symId) continue;

        a=kA; b=kB; break;
      }
      if(a && b) break;
    }

    if(!a || !b){
      const slice = symbols.slice(idx);
      shuffleInPlace(slice);
      for(let i=0;i<slice.length;i++) symbols[idx+i] = slice[i];
      continue;
    }

    assigned.set(a, sym);
    assigned.set(b, sym);

    {
      const [,gxA,gyA] = a.split(':');
      const [,gxB,gyB] = b.split(':');
      columnSymbol.set(`${gxA}:${gyA}`, symId);
      columnSymbol.set(`${gxB}:${gyB}`, symId);
    }

    remaining.delete(a);
    remaining.delete(b);
    idx += 2;
  }

  state.tiles = state.layout.map((pos, id) => ({
    id,
    pos,
    symbol: assigned.get(kpos(pos)),
    matched: false,
    selected: false,
    free: false,
    // screen coords for keyboard navigation (set during render)
    screenX: 0,
    screenY: 0
  }));

  state.matches = 0;
  state.remaining = 64;
  state.totalTiles = 64;
  state.selectedId = null;

  // initial focus goes to any free tile after updateFree()
  state.focusedTileId = null;
}

function computeGeometry(){
  const containerW = dom.board.clientWidth || dom.board.parentElement.clientWidth || 600;
  const tileW = Math.max(46, Math.min(78, Math.floor(containerW / 10.2)));
  const tileH = Math.round(tileW * (87/70));
  const stepX = Math.round(tileW * 0.78);
  const stepY = Math.round(tileH * 0.78);
  const pad = Math.round(tileW * 0.35);
  const liftX = Math.round(tileW * 0.14);
  const liftY = Math.round(tileH * 0.10);

  let minX=1e9, minY=1e9, maxX=0, maxY=0;
  for(const p of state.layout){
    const x = pad + p.gx*stepX + (p.l-1)*liftX;
    const y = pad + p.gy*stepY - (p.l-1)*liftY;
    minX = Math.min(minX, x); minY = Math.min(minY, y);
    maxX = Math.max(maxX, x); maxY = Math.max(maxY, y);
  }

  state.geom = { tileW, tileH, stepX, stepY, pad, liftX, liftY, minX, minY };
  dom.board.style.height = `${Math.ceil((maxY-minY)+tileH+pad*2)}px`;
}

function updateFree(){
  const occ = new Set();
  for(const t of state.tiles) if(!t.matched) occ.add(kpos(t.pos));
  const freeKeys = computeFreeSet(occ);

  for(const t of state.tiles){
    if(t.matched){ t.free=false; continue; }
    t.free = freeKeys.has(kpos(t.pos));
  }

  const active = state.tiles.filter(t=>!t.matched);
  if(active.length <= 4) for(const t of active) t.free = true;

  // Ensure we always have a focused tile id (prefer free tiles)
  const currentFocused = state.tiles.find(t => t.id === state.focusedTileId && !t.matched);
  if(!currentFocused){
    const firstFree = state.tiles.find(t => !t.matched && t.free);
    const firstAny = state.tiles.find(t => !t.matched);
    state.focusedTileId = (firstFree || firstAny) ? (firstFree || firstAny).id : null;
  }
}

/** ==================== ACCESSIBLE RENDER ==================== */
function ariaLabelForTile(t){
  const status = t.free ? 'free' : 'blocked';
  const layer = `layer ${t.pos.l}`;
  return `${t.symbol.name} tile, ${status}, ${layer}. Press Enter to select.`;
}

function render(){
  computeGeometry();
  dom.board.innerHTML = '';

  const { tileW, tileH, stepX, stepY, pad, liftX, liftY, minX, minY } = state.geom;

  const sorted = [...state.tiles].sort((a,b)=>{
    if(a.pos.l !== b.pos.l) return a.pos.l - b.pos.l;
    if(a.pos.gy !== b.pos.gy) return a.pos.gy - b.pos.gy;
    return a.pos.gx - b.pos.gx;
  });

  for(const t of sorted){
    if(t.matched) continue;

    const el = document.createElement('div');
    el.className = 'tile';
    el.dataset.id = String(t.id);

    // Accessibility: treat tile as button
    el.setAttribute('role', 'button');
    el.setAttribute('aria-label', ariaLabelForTile(t));
    el.setAttribute('aria-disabled', String(!t.free));
    el.setAttribute('aria-pressed', String(!!t.selected));

    // Roving tabindex: only the focused tile is tabbable
    const isFocused = state.focusedTileId === t.id;
    el.tabIndex = isFocused ? 0 : -1;

    if(t.selected) el.classList.add('selected');
    if(!t.free) el.classList.add('blocked');

    const x = pad + t.pos.gx*stepX + (t.pos.l-1)*liftX - minX + pad;
    const y = pad + t.pos.gy*stepY - (t.pos.l-1)*liftY - minY + pad;

    t.screenX = x + tileW/2;
    t.screenY = y + tileH/2;

    el.style.left = `${x}px`;
    el.style.top = `${y}px`;
    el.style.width = `${tileW}px`;
    el.style.height = `${tileH}px`;
    el.style.zIndex = String(t.pos.l*1000 + t.pos.gy*10 + t.pos.gx);

    const img = document.createElement('img');
    img.src = `images/${t.symbol.imageFile}`;
    img.alt = t.symbol.name;
    img.onerror = function(){
      const initial = encodeURIComponent(t.symbol.name.charAt(0).toUpperCase());
      this.src = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="70" height="87" viewBox="0 0 70 87"><rect width="70" height="87" fill="%23b08968" rx="12"/><text x="35" y="52" font-family="Arial" font-size="26" fill="%23f9a826" text-anchor="middle">${initial}</text></svg>`;
    };
    el.appendChild(img);

    el.addEventListener('click', () => {
      // user gesture can unlock audio
      if(state.soundEnabled) ensureAudio();
      soundClick();
      selectTile(t.id);
    });

    el.addEventListener('focus', () => {
      state.focusedTileId = t.id;
      // keep aria/visual focus stable without re-render
      updateRovingTabIndex();
    });

    dom.board.appendChild(el);
  }

  updateButtons();

  // After render, focus the currently focused tile if it exists and the user is navigating by keyboard
  // (We won't forcibly focus on every render to avoid stealing focus.)
}

function updateRovingTabIndex(){
  const tiles = dom.board.querySelectorAll('.tile');
  tiles.forEach(el => {
    const id = Number(el.dataset.id);
    el.tabIndex = (id === state.focusedTileId) ? 0 : -1;
  });
}

/** ==================== MATCH FINDING ==================== */
function findMatches(){
  const free = state.tiles.filter(t=>!t.matched && t.free);
  const map = new Map();
  for(const t of free){
    if(!map.has(t.symbol.id)) map.set(t.symbol.id, []);
    map.get(t.symbol.id).push(t);
  }
  const pairs = [];
  for(const arr of map.values()){
    if(arr.length>=2) pairs.push([arr[0], arr[1]]);
  }
  return pairs;
}

/** ==================== GAMEPLAY ==================== */
function selectTile(id){
  const t = state.tiles.find(x=>x.id===id);
  if(!t || t.matched || !t.free) return;

  if(state.selectedId === null){
    for(const x of state.tiles) x.selected=false;
    t.selected=true;
    state.selectedId=t.id;
    showInfo(t.symbol);
    render();
    focusTile(state.focusedTileId ?? t.id);
    return;
  }

  if(state.selectedId === t.id){
    t.selected=false;
    state.selectedId=null;
    render();
    focusTile(t.id);
    return;
  }

  const first = state.tiles.find(x=>x.id===state.selectedId);
  if(!first){ state.selectedId=null; return; }

  if(first.symbol.id === t.symbol.id){
    first.matched=true; t.matched=true;
    first.selected=false; t.selected=false;
    state.selectedId=null;
    state.matches += 1;
    state.remaining -= 2;

    soundMatch();

    updateFree();
    updateStats();
    render();

    // keep focus on a free tile after changes
    focusTile(state.focusedTileId);

    if(state.remaining===0) win();
    else showMsg("Good match!");
  } else {
    // wrong match feedback
    soundWrong();

    first.selected=true; t.selected=true;
    render();

    if(!state.reducedMotion){
      const el1 = document.querySelector(`.tile[data-id="${first.id}"]`);
      const el2 = document.querySelector(`.tile[data-id="${t.id}"]`);
      if(el1) el1.classList.add('wrong-match');
      if(el2) el2.classList.add('wrong-match');
    }

    setTimeout(()=>{
      first.selected=false; t.selected=false;
      state.selectedId=null;
      render();
      focusTile(t.id);
      showMsg(lossProverbs[Math.floor(Math.random()*lossProverbs.length)]);
    }, 420);
  }
}

function focusTile(tileId){
  if(tileId === null || tileId === undefined) return;
  state.focusedTileId = tileId;
  updateRovingTabIndex();
  const el = dom.board.querySelector(`.tile[data-id="${tileId}"]`);
  if(el) el.focus({ preventScroll: true });
}

/** ==================== KEYBOARD NAVIGATION ==================== */
function getFocusableTiles(){
  return state.tiles.filter(t => !t.matched); // can focus blocked too, but selection requires free
}

function findNearestInDirection(fromTile, dir){
  const tiles = getFocusableTiles().filter(t => t.id !== fromTile.id);

  // Directional filter + score by angle/primary axis distance
  const fx = fromTile.screenX;
  const fy = fromTile.screenY;

  let best = null;
  let bestScore = Infinity;

  for(const t of tiles){
    const dx = t.screenX - fx;
    const dy = t.screenY - fy;

    // must be in intended half-plane
    if(dir === 'left' && dx >= 0) continue;
    if(dir === 'right' && dx <= 0) continue;
    if(dir === 'up' && dy >= 0) continue;
    if(dir === 'down' && dy <= 0) continue;

    const primary = (dir === 'left' || dir === 'right') ? Math.abs(dx) : Math.abs(dy);
    const secondary = (dir === 'left' || dir === 'right') ? Math.abs(dy) : Math.abs(dx);

    // Favor closest in primary axis, penalize drift
    const score = primary + secondary * 0.35;

    if(score < bestScore){
      bestScore = score;
      best = t;
    }
  }

  return best;
}

function onBoardKeyDown(e){
  const key = e.key;
  const focusId = state.focusedTileId;

  const current = state.tiles.find(t => t.id === focusId && !t.matched);
  if(!current) return;

  if(key === 'ArrowLeft' || key === 'ArrowRight' || key === 'ArrowUp' || key === 'ArrowDown'){
    e.preventDefault();
    const dir = (key === 'ArrowLeft') ? 'left'
      : (key === 'ArrowRight') ? 'right'
      : (key === 'ArrowUp') ? 'up'
      : 'down';

    const next = findNearestInDirection(current, dir);
    if(next){
      state.focusedTileId = next.id;
      focusTile(next.id);
    }
    return;
  }

  if(key === 'Enter' || key === ' '){
    e.preventDefault();
    if(state.soundEnabled) ensureAudio();
    soundClick();
    selectTile(current.id);
  }
}

// Attach one keydown handler on the document so it works reliably
document.addEventListener('keydown', (e) => {
  // Ignore if a dialog is open
  if(!dom.win.classList.contains('hidden')) return;

  // Only act if focus is within the board tiles (or no focus but we have a focusedTileId)
  const active = document.activeElement;
  const isTile = active && active.classList && active.classList.contains('tile');
  const isInBoard = isTile || (state.focusedTileId !== null);
  if(!isInBoard) return;

  onBoardKeyDown(e);
});

/** ==================== UI ACTIONS ==================== */
function hint(){
  const m = findMatches();
  if(!m.length) return;
  const [a,b] = m[0];

  a.selected=true; b.selected=true;
  showInfo(a.symbol);
  render();

  setTimeout(()=>{ a.selected=false; b.selected=false; render(); focusTile(state.focusedTileId); }, 1600);
}

function shuffleSymbols(force=false){
  if(!force && state.shufflesRemaining<=0) return showMsg("No shuffles left!");
  if(!force){
    state.shufflesRemaining -= 1;
    updateShuffleCount();
  }

  if(state.selectedId !== null){
    const sel = state.tiles.find(t=>t.id===state.selectedId);
    if(sel) sel.selected=false;
    state.selectedId=null;
  }

  const u = state.tiles.filter(t=>!t.matched);
  const syms = u.map(t=>t.symbol);
  shuffleInPlace(syms);
  for(let i=0;i<u.length;i++) u[i].symbol = syms[i];

  updateFree();
  render();
  focusTile(state.focusedTileId);
  showMsg("Ingredients stirred and rearranged!");
}

function updateStats(){
  dom.matches.textContent = String(state.matches);
  dom.remaining.textContent = String(state.remaining);
  dom.level.textContent = String(state.level);
  dom.total.textContent = String(state.totalTiles);
  updateShuffleCount();
}

function updateShuffleCount(){
  dom.shuffleCount.textContent = String(state.shufflesRemaining);
  dom.shuffleWarning.textContent = state.shufflesRemaining===0
    ? "No shuffles remaining ‚Äî but the game can still be solvable"
    : "";
}

function updateButtons(){
  const m = findMatches();
  dom.hint.disabled = m.length===0;
  dom.shuffle.disabled = state.shufflesRemaining<=0;
}

function startTimer(){
  state.startTime = new Date();
  clearInterval(state.timerInterval);
  state.timerInterval = setInterval(()=>{
    const now = new Date();
    state.elapsed = Math.floor((now - state.startTime)/1000);
    const mm = Math.floor(state.elapsed/60);
    const ss = state.elapsed%60;
    dom.time.textContent = `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
  }, 1000);
}

function win(){
  clearInterval(state.timerInterval);
  dom.winText.textContent = `üéâ Level ${state.level} Complete!`;
  dom.win.classList.remove('hidden');
}

function reset(){
  clearInterval(state.timerInterval);
  dom.win.classList.add('hidden');
  state.level = 1;
  init();
}

function nextLevel(){
  clearInterval(state.timerInterval);
  dom.win.classList.add('hidden');
  state.level += 1;
  init();
}

function init(){
  state.shufflesRemaining = 3;
  generateWinnable();
  updateFree();
  updateStats();
  startTimer();
  render();
  showInfo({name:"Select a tile", meaning:"Click any ingredient to learn about its place in African cooking"});
  focusTile(state.focusedTileId);
}

/** ==================== EVENTS ==================== */
dom.hint.addEventListener('click', () => { if(state.soundEnabled) ensureAudio(); hint(); });
dom.shuffle.addEventListener('click', () => { if(state.soundEnabled) ensureAudio(); shuffleSymbols(false); });
dom.reset.addEventListener('click', () => { if(state.soundEnabled) ensureAudio(); reset(); });
dom.next.addEventListener('click', () => { if(state.soundEnabled) ensureAudio(); nextLevel(); });
dom.again.addEventListener('click', () => { if(state.soundEnabled) ensureAudio(); reset(); });

dom.soundBtn.addEventListener('click', () => {
  state.soundEnabled = !state.soundEnabled;
  updateSoundButton();
  if(state.soundEnabled){
    ensureAudio();
    soundClick();
    showMsg("Sound on.");
  }else{
    showMsg("Sound off.");
  }
});

window.addEventListener('DOMContentLoaded', () => {
  updateSoundButton();
  init();
});

window.addEventListener('resize', () => {
  render();
  // keep focus stable
  focusTile(state.focusedTileId);
});
</script>
</body>
</html>
