<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The African Pantry Mahjong</title>
    <meta property="og:title" content="The African Pantry Mahjong">
    <meta property="og:description" content="Match ingredients, discover recipes, and explore African foodways.">
    <meta property="og:url" content="https://chicafricanculture.github.io/The-African-Pantry-Mahjong/">
    <meta property="og:type" content="website">
    
    <style>
    
        body {
            background: linear-gradient(135deg, #1a2a3a, #0d1b2a);
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 40px 20px;
            background: linear-gradient(rgba(13, 27, 42, 0.9), rgba(13, 27, 42, 0.9));
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            color: #f9a826;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #b8c7d6;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .archive-link {
            text-align: center;
            margin: 0.5rem 0 1.5rem;
            font-size: 1rem;
            color: #6a5f52;
        }
        
        .archive-link a {
            color: #f9a826;
            text-decoration: none;
        }
        
        .game-area {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .board-container {
            background: rgba(13, 27, 42, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 600px;
            position: relative;
        }
        
        .info-panel {
            background: rgba(13, 27, 42, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            background: rgba(26, 42, 58, 0.6);
            padding: 15px;
            border-radius: 10px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #f9a826;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #b8c7d6;
        }
        
        .symbol-info {
            background: rgba(26, 42, 58, 0.6);
            padding: 15px;
            border-radius: 10px;
            min-height: 80px;
        }
        
        .symbol-name {
            font-size: 1.2rem;
            color: #f9a826;
            margin-bottom: 8px;
        }
        
        .symbol-meaning {
            font-size: 0.9rem;
            line-height: 1.4;
            color: #b8c7d6;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        button {
            background: linear-gradient(135deg, #f9a826, #e8951e);
            color: #1a2a3a;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(249, 168, 38, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .mahjong-board {
            display: block;
            position: relative;
            min-height: 550px;
            width: 100%;
        }
        
        .tile {
            width: 70px;
            height: 87px;
            background: linear-gradient(145deg, #e8d0b0, #b08968);
            border: 3px solid #c49a6c;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 5px 10px rgba(0,0,0,0.4);
            position: absolute;
            overflow: hidden;
            padding: 5px;
        }
        
        .tile:hover:not(.blocked):not(.matched) {
            transform: scale(1.05) translateY(-3px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.5);
            z-index: 100;
        }
        
        .tile.selected {
            transform: translateY(-8px);
            box-shadow: 0 0 20px #d97706, 0 8px 16px rgba(0,0,0,0.5);
            border-color: #d97706;
            z-index: 200;
        }
        
        .tile.matched {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        
        .tile.blocked {
            opacity: 0.6;
            filter: saturate(0.5);
            cursor: not-allowed !important;
            pointer-events: none;
        }
        
        .tile.wrong-match {
            animation: shake 0.4s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
            border-color: #ff4444 !important;
        }
        
        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(4px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
        }
        
        .tile img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }
        
        .tile.level-1 { z-index: 10; }
        .tile.level-2 { z-index: 20; }
        .tile.level-3 { z-index: 30; }
        .tile.level-4 { z-index: 40; }
        
        .proverb-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(249, 168, 38, 0.95);
            color: #1a2a3a;
            padding: 20px 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            animation: floatIn 0.5s ease-out;
        }
        
        @keyframes floatIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .level-indicator {
            background: rgba(26, 42, 58, 0.6);
            padding: 10px 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .level-text {
            font-size: 1.1rem;
            color: #f9a826;
            font-weight: bold;
        }
        
        .win-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 27, 42, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }
        
        .win-message h2 {
            font-size: 2.5rem;
            color: #f9a826;
            margin-bottom: 20px;
        }
        
        .win-message p {
            font-size: 1.2rem;
            margin-bottom: 25px;
            color: #b8c7d6;
            max-width: 500px;
        }
        
        .win-message button {
            margin: 10px;
            min-width: 150px;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 1200px) {
            .tile {
                width: 60px;
                height: 75px;
            }
            
            .board-container {
                min-height: 550px;
            }
            
            .game-area {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>The African Pantry Mahjong</h1>
            <p class="subtitle">Match ingredients, discover recipes, and explore African foodways.</p>
        </header>
        
        <p class="archive-link">
            Part of the <strong>African Foodways</strong> project. 
            Explore the <a href="https://chicafricanculture.github.io/african-foodways-data/">main archive, field notes, and recipes here</a>.
        </p>
        
        <div class="game-area">
            <div class="board-container">
                <div class="level-indicator">
                    <div class="level-text">Level: <span id="level">1</span> | Tiles: <span id="total-tiles">64</span></div>
                </div>
                <div class="mahjong-board" id="board"></div>
            </div>
            
            <div class="info-panel">
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="matches">0</div>
                        <div class="stat-label">Matches</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="remaining">64</div>
                        <div class="stat-label">Remaining</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="time">00:00</div>
                        <div class="stat-label">Time</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="shuffle-count">3</div>
                        <div class="stat-label">Shuffles</div>
                    </div>
                </div>
                
                <div class="symbol-info">
                    <div class="symbol-name" id="symbol-name">Select a tile</div>
                    <div class="symbol-meaning" id="symbol-meaning">Click any ingredient to learn about it</div>
                </div>
                
                <div class="controls">
                    <button id="hint-btn">üîç Hint</button>
                    <button id="shuffle-btn">üîÑ Shuffle</button>
                    <button id="reset-btn">üÜï New Game</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="win-message hidden" id="win-message">
        <h2>üéâ Pantry Cleared! üéâ</h2>
        <p id="win-text">You've matched all the ingredients!</p>
        <button id="next-level-btn">‚¨ÜÔ∏è Next Level</button>
        <button id="play-again-btn">üîÑ Play Again</button>
    </div>

<script>
// African food proverbs
const proverbs = [
    "The one who eats alone cannot discuss the taste of the food with others.",
    "The firewood that cooks the food is the same one that burns the cook.",
    "Soup that is too hot makes one wait before eating.",
    "A full belly is the mother of all songs.",
    "You cannot taste honey without burning your tongue.",
    "The best fish smell when they are three days old.",
    "If you want to eat a lot of food, don't wash your hands too clean.",
    "One cannot prepare soup without water.",
    "However long the night, the dawn will break.",
    "A single bracelet does not jingle."
];

const lossProverbs = [
    "The pot that boils too much loses its flavor.",
    "Even the best cook sometimes burns the stew.",
    "A bad cook blames his pots and pestle.",
    "When the cooking pot is empty, the fire feels ashamed.",
    "A fall is not a failure, but a failure to rise is.",
    "The elephant does not get tired of its trunk."
];

// African food symbols - using ONLY the PNG files you have
const foodSymbols = [
    { id: 1, name: "Baobab", meaning: "Baobab fruit - vitamin-rich powder for drinks and sauces.", imageFile: "baobab.png" },
    { id: 2, name: "Bee", meaning: "Honey - natural sweetener in traditional cooking.", imageFile: "bee.png" },
    { id: 3, name: "Beer", meaning: "Traditional sorghum and millet beers.", imageFile: "beer.png" },
    { id: 4, name: "Chef's Hands", meaning: "The skilled hands that prepare our meals.", imageFile: "chef-hands.png" },
    { id: 5, name: "Cooking Spoon", meaning: "The wooden spoon that stirs communities together.", imageFile: "cooking-spoon.png" },
    { id: 6, name: "Corn", meaning: "Maize - kenkey, ugali, and porridges.", imageFile: "corn.png" },
    { id: 7, name: "Cow", meaning: "Suya, rich stews, and traditional ceremonies.", imageFile: "cow.png" },
    { id: 8, name: "Crab", meaning: "Coastal soups and crab pepper soup.", imageFile: "crab.png" },
    { id: 9, name: "Egg", meaning: "Ghanaian egg stew, boiled eggs in puff-puff.", imageFile: "egg.png" },
    { id: 10, name: "Egusi", meaning: "Melon seeds - thickener for soups and stews.", imageFile: "Egusi.png" },
    { id: 11, name: "Fire", meaning: "Traditional cooking methods and hearths.", imageFile: "fire.png" },
    { id: 12, name: "Fish", meaning: "Grilled tilapia, fish pepper soups.", imageFile: "fish.png" },
    { id: 13, name: "Fishing", meaning: "River and coastal communities.", imageFile: "fishing.png" },
    { id: 14, name: "Fufu", meaning: "Pounded cassava and plantain - West African staple.", imageFile: "fufu.png" },
    { id: 15, name: "Goat", meaning: "Goat pepper soup, ceremonial dishes.", imageFile: "goat.png" },
    { id: 16, name: "Grain", meaning: "Millet, sorghum, teff - ancient grains.", imageFile: "grain.png" },
    { id: 17, name: "Hibiscus", meaning: "Zobo drink, sorrel - refreshing beverages.", imageFile: "hibiscus.png" },
    { id: 18, name: "Maggi", meaning: "Essential seasoning in modern African cooking.", imageFile: "maggi.png" },
    { id: 19, name: "Mango", meaning: "Sweet tropical fruit - fresh or dried.", imageFile: "Mango.png" },
    { id: 20, name: "Mortar", meaning: "Pounding fufu, grinding spices.", imageFile: "mortor.png" },
    { id: 21, name: "Palm Oil", meaning: "Banga soup, essential for stews.", imageFile: "palm-oil.png" },
    { id: 22, name: "Pepper", meaning: "Scotch bonnet, peri-peri, spice blends.", imageFile: "pepper.png" },
    { id: 23, name: "Plantain", meaning: "Kelewele, dodo, fried plantains.", imageFile: "plantain.png" },
    { id: 24, name: "Plate", meaning: "Communal dining and sharing meals.", imageFile: "plate.png" },
    { id: 25, name: "Pot", meaning: "One-pot cooking, communal meals.", imageFile: "pot.png" },
    { id: 26, name: "Rice", meaning: "Jollof, fried rice, coconut rice.", imageFile: "rice.png" },
    { id: 27, name: "Salt", meaning: "Preservation and flavor.", imageFile: "salt.png" },
    { id: 28, name: "Street Hawkers", meaning: "Mobile food vendors and street food culture.", imageFile: "street-hawkers.png" },
    { id: 29, name: "Vegetables", meaning: "Cassava leaves, bitterleaf, spinach.", imageFile: "vegetables.png" },
    { id: 30, name: "Water", meaning: "The foundation of all cooking.", imageFile: "water.png" },
    { id: 31, name: "Wood", meaning: "Fuel for traditional cooking fires.", imageFile: "wood.png" },
    { id: 32, name: "Yam", meaning: "Yam pottage (asaro), boiled yam with sauces.", imageFile: "yam.png" }
];

// Game state
let gameState = {
    tiles: [],
    selectedTile: null,
    matches: 0,
    remaining: 0,
    startTime: null,
    timerInterval: null,
    elapsedTime: 0,
    level: 1,
    totalTiles: 64,
    lastMoveTime: null,
    stuckTimer: null,
    proverbShown: false,
    shufflesRemaining: 3,
    wrongMatchTimer: null
};

// DOM elements
const boardElement = document.getElementById('board');
const matchesElement = document.getElementById('matches');
const remainingElement = document.getElementById('remaining');
const timeElement = document.getElementById('time');
const levelElement = document.getElementById('level');
const totalTilesElement = document.getElementById('total-tiles');
const symbolNameElement = document.getElementById('symbol-name');
const symbolMeaningElement = document.getElementById('symbol-meaning');
const hintButton = document.getElementById('hint-btn');
const shuffleButton = document.getElementById('shuffle-btn');
const resetButton = document.getElementById('reset-btn');
const nextLevelButton = document.getElementById('next-level-btn');
const playAgainButton = document.getElementById('play-again-btn');
const winMessage = document.getElementById('win-message');
const winText = document.getElementById('win-text');
const shuffleCountElement = document.getElementById('shuffle-count');

// Initialize the game
function initGame() {
    createTiles();
    updateFreeTiles();
    renderBoard();
    startTimer();
    updateStats();
    gameState.lastMoveTime = new Date();
    gameState.proverbShown = false;
    gameState.shufflesRemaining = 3;
    updateShuffleCount();
    startStuckDetection();
}

// Create tiles with proper Mahjong stacking
function createTiles() {
    gameState.tiles = [];
    
    // 64 tiles exactly - fits pyramid perfectly
    const tilesNeeded = 64;
    const symbolCount = foodSymbols.length; // 32 symbols
    
    // Create array of symbols - each symbol appears exactly twice
    let symbolPool = [];
    for (let i = 0; i < symbolCount; i++) {
        symbolPool.push(foodSymbols[i]); // First copy
        symbolPool.push(foodSymbols[i]); // Second copy
    }
    
    console.log("Total symbols in pool:", symbolPool.length);
    
    // Shuffle the symbol pool thoroughly
    for (let i = symbolPool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbolPool[i], symbolPool[j]] = [symbolPool[j], symbolPool[i]];
    }
    
    // Generate pyramid positions
    const positions = generatePyramidPositions(tilesNeeded);
    
    // Create tiles
    for (let i = 0; i < tilesNeeded; i++) {
        gameState.tiles.push({
            id: i,
            symbol: symbolPool[i],
            matched: false,
            selected: false,
            x: positions[i].x,
            y: positions[i].y,
            level: positions[i].level,
            free: false
        });
    }
    
    // Ensure game is solvable
    updateFreeTiles();
    let attempts = 0;
    while (findAvailableMatches().length === 0 && attempts < 50) {
        const symbols = gameState.tiles.map(t => t.symbol);
        for (let k = symbols.length - 1; k > 0; k--) {
            const j = Math.floor(Math.random() * (k + 1));
            [symbols[k], symbols[j]] = [symbols[j], symbols[k]];
        }
        gameState.tiles.forEach((t, i) => { t.symbol = symbols[i]; });
        updateFreeTiles();
        attempts++;
    }
    console.log(`Solvability shuffles: ${attempts}`);
    
    gameState.matches = 0;
    gameState.remaining = tilesNeeded;
    gameState.totalTiles = tilesNeeded;
}

// Generate pyramid positions with proper stacking
function generatePyramidPositions(totalTiles) {
    const positions = [];
    const columns = 8;
    const rowStep = 95; // Height + gap
    const tileWidth = 85;

    const levelConfigs = [
        { rows: 3, yOffset: 0, xOffset: 15 },   // Bottom level (level 1) - widest
        { rows: 3, yOffset: 25, xOffset: 10 },  // Level 2
        { rows: 2, yOffset: 45, xOffset: 5 },   // Level 3
        { rows: 1, yOffset: 65, xOffset: 0 }    // Top level (level 4) - narrowest
    ];

    let tileIndex = 0;

    // Fill from bottom to top
    for (let level = 0; level < levelConfigs.length; level++) {
        const config = levelConfigs[level];
        const levelNumber = level + 1; // Bottom=1 (behind), top=4 (front)

        for (let row = 0; row < config.rows; row++) {
            let tilesInRow = columns;
            if (level === 2) tilesInRow = 6;  // Level 3 narrower
            if (level === 3) tilesInRow = 4;  // Top level narrowest

            const startCol = Math.floor((columns - tilesInRow) / 2);

            for (let col = 0; col < tilesInRow; col++) {
                if (tileIndex >= totalTiles) break;

                positions.push({
                    x: (startCol + col) * tileWidth + config.xOffset,
                    y: row * rowStep + config.yOffset,
                    level: levelNumber
                });

                tileIndex++;
            }
            if (tileIndex >= totalTiles) break;
        }
        if (tileIndex >= totalTiles) break;
    }

    // Flip Y to orient pyramid correctly (narrow at top, wide at bottom)
    const ys = positions.map(p => p.y);
    const maxY = Math.max(...ys);
    positions.forEach(p => {
        p.y = 20 + (maxY - p.y); // Flip + top padding
    });

    console.log(`Generated ${positions.length} positions`);
    return positions;
}

// Real Mahjong free-tile detection
function updateFreeTiles() {
    const active = gameState.tiles.filter(t => !t.matched);
    
    // First, mark all active tiles as potentially free
    active.forEach(t => t.free = true);
    
    // Check each tile to see if it's covered by any tile above it
    active.forEach(tile => {
        active.forEach(other => {
            if (other.id === tile.id) return;
            
            // If other tile is on a higher level and overlaps this tile, this tile is blocked
            if (other.level > tile.level) {
           // Check if other tile overlaps this one - stricter detection
const overlapX = Math.abs(tile.x - other.x) < 60; // Reduced from 65
const overlapY = Math.abs(tile.y - other.y) < 75; // Reduced from 80
                
                if (overlapX && overlapY) {
                    tile.free = false;
                }
            }
        });
    });
    
    // After updating, check if game is unwinnable
    checkUnwinnable();
}

// Check if game is unwinnable and handle it
function checkUnwinnable() {
    const activeTiles = gameState.tiles.filter(t => !t.matched);
    const freeTiles = activeTiles.filter(t => t.free);
    
    if (freeTiles.length === 0 && activeTiles.length > 0) {
        setTimeout(() => {
            showProverbMessage("The pot is stuck! Auto-shuffling...");
            shuffleTiles(true);
        }, 500);
        return;
    }
    
if (matches.length === 0 && activeTiles.length > 0) {
    setTimeout(() => {
        if (gameState.shufflesRemaining > 0) {
            showProverbMessage("No matches available. Stirring the pot...");
            shuffleTiles(false);
        } else {
            // Auto-shuffle anyway when out of shuffles, but don't decrement
            showProverbMessage("No matches - forced shuffle!");
            shuffleTiles(true); // 'true' means forced shuffle (doesn't use a shuffle count)
        }
    }, 500);
}

// Find available matches among FREE tiles only
function findAvailableMatches() {
    const matches = [];
    const freeTiles = gameState.tiles.filter(tile => !tile.matched && tile.free);
    
    for (let i = 0; i < freeTiles.length; i++) {
        for (let j = i + 1; j < freeTiles.length; j++) {
            if (freeTiles[i].symbol.id === freeTiles[j].symbol.id) {
                matches.push([freeTiles[i], freeTiles[j]]);
            }
        }
    }
    return matches;
}

// Render the game board
function renderBoard() {
    boardElement.innerHTML = '';
    
    // Sort tiles by level (higher levels rendered first so lower levels appear on top)
    const sortedTiles = [...gameState.tiles].sort((a, b) => b.level - a.level);
    
    sortedTiles.forEach(tile => {
        if (!tile.matched) {
            const tileElement = document.createElement('div');
            tileElement.className = `tile level-${tile.level}`;
            tileElement.dataset.id = tile.id;
            
            if (tile.selected) {
                tileElement.classList.add('selected');
            }
            
            if (!tile.free) {
                tileElement.classList.add('blocked');
            }
            
            tileElement.style.left = `${tile.x}px`;
            tileElement.style.top = `${tile.y}px`;
            
            const img = document.createElement('img');
            img.src = `images/${tile.symbol.imageFile}`;
            img.alt = tile.symbol.name;
            img.onerror = function() {
                this.src = 'https://via.placeholder.com/70x87/f9a826/1a2a3a?text=' + tile.symbol.name.charAt(0);
            };
            tileElement.appendChild(img);
            
            tileElement.addEventListener('click', (e) => {
                e.stopPropagation();
                selectTile(tile);
            });
            
            boardElement.appendChild(tileElement);
        }
    });
}

// Handle tile selection
function selectTile(tile) {
    if (tile.matched || !tile.free) return;
    
    gameState.lastMoveTime = new Date();
    gameState.proverbShown = false;
    
    if (!gameState.selectedTile) {
        gameState.tiles.forEach(t => t.selected = false);
        tile.selected = true;
        gameState.selectedTile = tile;
        showSymbolInfo(tile.symbol);
        renderBoard();
        return;
    }
    
    if (gameState.selectedTile.id === tile.id) {
        gameState.selectedTile.selected = false;
        gameState.selectedTile = null;
        renderBoard();
        return;
    }
    
    if (gameState.selectedTile.symbol.id === tile.symbol.id) {
        gameState.selectedTile.matched = true;
        tile.matched = true;
        gameState.matches++;
        gameState.remaining -= 2;
        
        gameState.selectedTile.selected = false;
        gameState.selectedTile = null;
        
        updateFreeTiles();
        renderBoard();
        updateStats();
        
        if (gameState.remaining === 0) {
            endLevel();
        }
    } else {
        showWrongMatch(tile);
    }
}

// Show wrong match animation
function showWrongMatch(tile) {
    // Store the selected tile
    const firstTile = gameState.selectedTile;
    
    // Show both as selected briefly
    firstTile.selected = true;
    tile.selected = true;
    renderBoard();
    
    setTimeout(() => {
        const firstEl = document.querySelector(`.tile[data-id="${firstTile.id}"]`);
        const secondEl = document.querySelector(`.tile[data-id="${tile.id}"]`);
        
        if (firstEl) firstEl.classList.add('wrong-match');
        if (secondEl) secondEl.classList.add('wrong-match');
        
        setTimeout(() => {
            if (firstEl) firstEl.classList.remove('wrong-match');
            if (secondEl) secondEl.classList.remove('wrong-match');
            
            firstTile.selected = false;
            tile.selected = false;
            gameState.selectedTile = null;
            renderBoard();
        }, 400);
    }, 100);
}

// Start stuck detection
function startStuckDetection() {
    clearInterval(gameState.stuckTimer);
    gameState.stuckTimer = setInterval(() => {
        const now = new Date();
        const timeSinceLastMove = (now - gameState.lastMoveTime) / 1000;
        
        if (timeSinceLastMove > 15 && !gameState.proverbShown && gameState.remaining > 0) {
            showEncouragingProverb();
            gameState.proverbShown = true;
        }
    }, 1000);
}

// Show encouraging proverb when stuck
function showEncouragingProverb() {
    const proverb = proverbs[Math.floor(Math.random() * proverbs.length)];
    showProverbMessage(proverb);
}

// Show proverb message
function showProverbMessage(proverb) {
    const existing = document.querySelector('.proverb-message');
    if (existing) existing.remove();
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'proverb-message';
    messageDiv.textContent = proverb;
    
    document.body.appendChild(messageDiv);
    
    setTimeout(() => {
        if (document.body.contains(messageDiv)) {
            document.body.removeChild(messageDiv);
        }
    }, 4000);
}

// Show symbol information
function showSymbolInfo(symbol) {
    symbolNameElement.textContent = symbol.name;
    symbolMeaningElement.textContent = symbol.meaning;
}

// Update game statistics
function updateStats() {
    matchesElement.textContent = gameState.matches;
    remainingElement.textContent = gameState.remaining;
    levelElement.textContent = gameState.level;
    totalTilesElement.textContent = gameState.totalTiles;
    updateShuffleCount();
}

// Update shuffle count display
function updateShuffleCount() {
    if (shuffleCountElement) {
        shuffleCountElement.textContent = gameState.shufflesRemaining;
    }
}

// Start the game timer
function startTimer() {
    gameState.startTime = new Date();
    clearInterval(gameState.timerInterval);
    
    gameState.timerInterval = setInterval(() => {
        const now = new Date();
        gameState.elapsedTime = Math.floor((now - gameState.startTime) / 1000);
        const minutes = Math.floor(gameState.elapsedTime / 60);
        const seconds = gameState.elapsedTime % 60;
        timeElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
}

// Provide a hint
function provideHint() {
    const availableMatches = findAvailableMatches();
    if (availableMatches.length > 0) {
        const match = availableMatches[0];
        match[0].selected = true;
        match[1].selected = true;
        renderBoard();
        
        setTimeout(() => {
            match[0].selected = false;
            match[1].selected = false;
            renderBoard();
        }, 2000);
    } else {
        showProverbMessage(lossProverbs[Math.floor(Math.random() * lossProverbs.length)]);
    }
}

// Shuffle tiles
function shuffleTiles(force = false) {
    if (!force && gameState.shufflesRemaining <= 0) {
        showProverbMessage("No shuffles left! Try a new game.");
        return;
    }
    
    if (!force) {
        gameState.shufflesRemaining--;
        updateShuffleCount();
    }
    
    if (gameState.selectedTile) {
        gameState.selectedTile.selected = false;
        gameState.selectedTile = null;
    }
    
    const unmatchedTiles = gameState.tiles.filter(tile => !tile.matched);
    const symbols = unmatchedTiles.map(tile => tile.symbol);
    
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    
    unmatchedTiles.forEach((tile, index) => {
        tile.symbol = symbols[index];
    });
    
    updateFreeTiles();
    renderBoard();
    
    showProverbMessage("Ingredients stirred and rearranged!");
}

// Reset game to level 1
function resetGame() {
    clearInterval(gameState.timerInterval);
    clearInterval(gameState.stuckTimer);
    winMessage.classList.add('hidden');
    gameState.level = 1;
    initGame();
}

// Go to next level
function nextLevel() {
    clearInterval(gameState.timerInterval);
    clearInterval(gameState.stuckTimer);
    winMessage.classList.add('hidden');
    gameState.level++;
    initGame();
}

// End current level
function endLevel() {
    clearInterval(gameState.timerInterval);
    clearInterval(gameState.stuckTimer);
    
    if (gameState.level === 1) {
        winText.textContent = `üéâ Level ${gameState.level} Complete! Ready for more challenging layouts?`;
    } else {
        winText.textContent = `üéâ Level ${gameState.level} Complete! You're becoming a master chef!`;
    }
    
    winMessage.classList.remove('hidden');
}

// Event listeners
hintButton.addEventListener('click', provideHint);
shuffleButton.addEventListener('click', () => shuffleTiles(false));
resetButton.addEventListener('click', resetGame);
nextLevelButton.addEventListener('click', nextLevel);
playAgainButton.addEventListener('click', resetGame);

// Initialize when page loads
window.addEventListener('DOMContentLoaded', initGame);
</script>
</body>
</html>
