<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The African Pantry Mahjong</title>
    <meta property="og:title" content="The African Pantry Mahjong">
    <meta property="og:description" content="Match ingredients, discover recipes, and explore African foodways.">
    <meta property="og:url" content="https://chicafricanculture.github.io/The-African-Pantry-Mahjong/">
    <meta property="og:type" content="website">
    
    <style>
    
        body {
            background: linear-gradient(135deg, #1a2a3a, #0d1b2a);
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 40px 20px;
            background: linear-gradient(rgba(13, 27, 42, 0.9), rgba(13, 27, 42, 0.9));
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            color: #f9a826;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.1rem;
            color: #b8c7d6;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .archive-link {
            text-align: center;
            margin: 0.5rem 0 1.5rem;
            font-size: 1rem;
            color: #6a5f52;
        }
        
        .archive-link a {
            color: #f9a826;
            text-decoration: none;
        }
        
        .game-area {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .board-container {
            background: rgba(13, 27, 42, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 600px;
            position: relative;
        }
        
        .info-panel {
            background: rgba(13, 27, 42, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            background: rgba(26, 42, 58, 0.6);
            padding: 15px;
            border-radius: 10px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #f9a826;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: #b8c7d6;
        }
        
        .symbol-info {
            background: rgba(26, 42, 58, 0.6);
            padding: 15px;
            border-radius: 10px;
            min-height: 80px;
        }
        
        .symbol-name {
            font-size: 1.2rem;
            color: #f9a826;
            margin-bottom: 8px;
        }
        
        .symbol-meaning {
            font-size: 0.9rem;
            line-height: 1.4;
            color: #b8c7d6;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        button {
            background: linear-gradient(135deg, #f9a826, #e8951e);
            color: #1a2a3a;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(249, 168, 38, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .mahjong-board {
            display: block;
            position: relative;
            min-height: 550px;
            width: 100%;
        }
        
        .tile {
            width: 70px;
            height: 87px;
            background: linear-gradient(145deg, #e8d0b0, #b08968);
            border: 3px solid #c49a6c;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 5px 10px rgba(0,0,0,0.4);
            position: absolute;
            overflow: hidden;
            padding: 5px;
        }
        
        .tile:hover:not(.blocked):not(.matched) {
            transform: scale(1.05) translateY(-3px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.5);
            z-index: 100;
        }
        
        .tile.selected {
            transform: translateY(-8px);
            box-shadow: 0 0 20px #d97706, 0 8px 16px rgba(0,0,0,0.5);
            border-color: #d97706;
            z-index: 200;
        }
        
        .tile.matched {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        
        .tile.blocked {
            opacity: 0.5;
            filter: brightness(0.7);
            cursor: not-allowed;
        }
        
        .tile.wrong-match {
            animation: shake 0.4s ease-in-out;
            border-color: #ff4444;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }
        
        .tile img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }
        
        .tile.level-1 { z-index: 10; }
        .tile.level-2 { z-index: 20; }
        .tile.level-3 { z-index: 30; }
        .tile.level-4 { z-index: 40; }
        .tile.level-5 { z-index: 50; }
        
        .proverb-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(249, 168, 38, 0.95);
            color: #1a2a3a;
            padding: 20px 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            animation: floatIn 0.5s ease-out;
        }
        
        @keyframes floatIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .level-indicator {
            background: rgba(26, 42, 58, 0.6);
            padding: 10px 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .level-text {
            font-size: 1.1rem;
            color: #f9a826;
            font-weight: bold;
        }
        
        .win-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 27, 42, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }
        
        .win-message h2 {
            font-size: 2.5rem;
            color: #f9a826;
            margin-bottom: 20px;
        }
        
        .win-message p {
            font-size: 1.2rem;
            margin-bottom: 25px;
            color: #b8c7d6;
            max-width: 500px;
        }
        
        .win-message button {
            margin: 10px;
            min-width: 150px;
        }
        
        .hidden {
            display: none;
        }
        
        .shuffle-count {
            font-size: 0.9rem;
            color: #f9a826;
            text-align: center;
            margin-top: 5px;
        }
        
        @media (max-width: 1200px) {
            .tile {
                width: 60px;
                height: 75px;
            }
            
            .board-container {
                min-height: 550px;
            }
            
            .game-area {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>The African Pantry Mahjong</h1>
            <p class="subtitle">Match ingredients, discover recipes, and explore African foodways.</p>
        </header>
        
        <p class="archive-link">
            Part of the <strong>African Foodways</strong> project. 
            Explore the <a href="https://chicafricanculture.github.io/african-foodways-data/">main archive, field notes, and recipes here</a>.
        </p>
        
        <div class="game-area">
            <div class="board-container">
                <div class="level-indicator">
                    <div class="level-text">Level: <span id="level">1</span> | Tiles: <span id="total-tiles">72</span></div>
                </div>
                <div class="mahjong-board" id="board"></div>
            </div>
            
            <div class="info-panel">
                <div class="stats">
                    <div class="stat">
                        <div class="stat-value" id="matches">0</div>
                        <div class="stat-label">Matches</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="remaining">72</div>
                        <div class="stat-label">Remaining</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="time">00:00</div>
                        <div class="stat-label">Time</div>
                    </div>
                </div>
                
                <div class="symbol-info">
                    <div class="symbol-name" id="symbol-name">Select a tile</div>
                    <div class="symbol-meaning" id="symbol-meaning">Click any ingredient to learn about it</div>
                </div>
                
                <div class="controls">
                    <button id="hint-btn">üîç Hint</button>
                    <button id="shuffle-btn">üîÑ Shuffle</button>
                    <button id="reset-btn">üÜï New Game</button>
                </div>
                <div class="shuffle-count" id="shuffle-count">Shuffles remaining: 3</div>
            </div>
        </div>
    </div>
    
    <div class="win-message hidden" id="win-message">
        <h2>üéâ Pantry Cleared! üéâ</h2>
        <p id="win-text">You've matched all the ingredients!</p>
        <button id="next-level-btn">‚¨ÜÔ∏è Next Level</button>
        <button id="play-again-btn">üîÑ Play Again</button>
    </div>

<script>
// African food proverbs
const proverbs = [
    "The one who eats alone cannot discuss the taste of the food with others.",
    "The firewood that cooks the food is the same one that burns the cook.",
    "Soup that is too hot makes one wait before eating.",
    "A full belly is the mother of all songs.",
    "You cannot taste honey without burning your tongue.",
    "The best fish smell when they are three days old.",
    "If you want to eat a lot of food, don't wash your hands too clean.",
    "One cannot prepare soup without water.",
    "However long the night, the dawn will break.",
    "A single bracelet does not jingle."
];

const lossProverbs = [
    "The pot that boils too much loses its flavor.",
    "Even the best cook sometimes burns the stew.",
    "A bad cook blames his pots and pestle.",
    "When the cooking pot is empty, the fire feels ashamed.",
    "A fall is not a failure, but a failure to rise is.",
    "The elephant does not get tired of its trunk."
];

// African food symbols - using ONLY the PNG files you have
const foodSymbols = [
    { id: 1, name: "Baobab", meaning: "Baobab fruit - vitamin-rich powder for drinks and sauces.", imageFile: "baobab.png" },
    { id: 2, name: "Bee", meaning: "Honey - natural sweetener in traditional cooking.", imageFile: "bee.png" },
    { id: 3, name: "Beer", meaning: "Traditional sorghum and millet beers.", imageFile: "beer.png" },
    { id: 4, name: "Chef's Hands", meaning: "The skilled hands that prepare our meals.", imageFile: "chef-hands.png" },
    { id: 5, name: "Cooking Spoon", meaning: "The wooden spoon that stirs communities together.", imageFile: "cooking-spoon.png" },
    { id: 6, name: "Corn", meaning: "Maize - kenkey, ugali, and porridges.", imageFile: "corn.png" },
    { id: 7, name: "Cow", meaning: "Suya, rich stews, and traditional ceremonies.", imageFile: "cow.png" },
    { id: 8, name: "Crab", meaning: "Coastal soups and crab pepper soup.", imageFile: "crab.png" },
    { id: 9, name: "Egg", meaning: "Ghanaian egg stew, boiled eggs in puff-puff.", imageFile: "egg.png" },
    { id: 10, name: "Egusi", meaning: "Melon seeds - thickener for soups and stews.", imageFile: "Egusi.png" },
    { id: 11, name: "Fire", meaning: "Traditional cooking methods and hearths.", imageFile: "fire.png" },
    { id: 12, name: "Fish", meaning: "Grilled tilapia, fish pepper soups.", imageFile: "fish.png" },
    { id: 13, name: "Fishing", meaning: "River and coastal communities.", imageFile: "fishing.png" },
    { id: 14, name: "Fufu", meaning: "Pounded cassava and plantain - West African staple.", imageFile: "fufu.png" },
    { id: 15, name: "Goat", meaning: "Goat pepper soup, ceremonial dishes.", imageFile: "goat.png" },
    { id: 16, name: "Grain", meaning: "Millet, sorghum, teff - ancient grains.", imageFile: "grain.png" },
    { id: 17, name: "Hibiscus", meaning: "Zobo drink, sorrel - refreshing beverages.", imageFile: "hibiscus.png" },
    { id: 18, name: "Maggi", meaning: "Essential seasoning in modern African cooking.", imageFile: "maggi.png" },
    { id: 19, name: "Mango", meaning: "Sweet tropical fruit - fresh or dried.", imageFile: "Mango.png" },
    { id: 20, name: "Mortar", meaning: "Pounding fufu, grinding spices.", imageFile: "mortor.png" },
    { id: 21, name: "Palm Oil", meaning: "Banga soup, essential for stews.", imageFile: "palm-oil.png" },
    { id: 22, name: "Pepper", meaning: "Scotch bonnet, peri-peri, spice blends.", imageFile: "pepper.png" },
    { id: 23, name: "Plantain", meaning: "Kelewele, dodo, fried plantains.", imageFile: "plantain.png" },
    { id: 24, name: "Plate", meaning: "Communal dining and sharing meals.", imageFile: "plate.png" },
    { id: 25, name: "Pot", meaning: "One-pot cooking, communal meals.", imageFile: "pot.png" },
    { id: 26, name: "Rice", meaning: "Jollof, fried rice, coconut rice.", imageFile: "rice.png" },
    { id: 27, name: "Salt", meaning: "Preservation and flavor.", imageFile: "salt.png" },
    { id: 28, name: "Street Hawkers", meaning: "Mobile food vendors and street food culture.", imageFile: "street-hawkers.png" },
    { id: 29, name: "Vegetables", meaning: "Cassava leaves, bitterleaf, spinach.", imageFile: "vegetables.png" },
    { id: 30, name: "Water", meaning: "The foundation of all cooking.", imageFile: "water.png" },
    { id: 31, name: "Wood", meaning: "Fuel for traditional cooking fires.", imageFile: "wood.png" },
    { id: 32, name: "Yam", meaning: "Yam pottage (asaro), boiled yam with sauces.", imageFile: "yam.png" }
];

// Game state
let gameState = {
    tiles: [],
    selectedTile: null,
    matches: 0,
    remaining: 0,
    startTime: null,
    timerInterval: null,
    elapsedTime: 0,
    level: 1,
    totalTiles: 72,
    lastMoveTime: null,
    stuckTimer: null,
    proverbShown: false,
    shufflesRemaining: 3,
    wrongMatchTimer: null
};

// DOM elements
const boardElement = document.getElementById('board');
const matchesElement = document.getElementById('matches');
const remainingElement = document.getElementById('remaining');
const timeElement = document.getElementById('time');
const levelElement = document.getElementById('level');
const totalTilesElement = document.getElementById('total-tiles');
const symbolNameElement = document.getElementById('symbol-name');
const symbolMeaningElement = document.getElementById('symbol-meaning');
const hintButton = document.getElementById('hint-btn');
const shuffleButton = document.getElementById('shuffle-btn');
const resetButton = document.getElementById('reset-btn');
const nextLevelButton = document.getElementById('next-level-btn');
const playAgainButton = document.getElementById('play-again-btn');
const winMessage = document.getElementById('win-message');
const winText = document.getElementById('win-text');
const shuffleCountElement = document.getElementById('shuffle-count');

// Initialize the game
function initGame() {
    createTiles();
    updateFreeTiles();
    renderBoard();
    startTimer();
    updateStats();
    gameState.lastMoveTime = new Date();
    gameState.proverbShown = false;
    gameState.shufflesRemaining = 3;
    updateShuffleCount();
    startStuckDetection();
}

// Create tiles with proper Mahjong stacking
function createTiles() {
    gameState.tiles = [];
    
    // Use all 32 symbols, duplicate to reach 72 tiles (each symbol appears 2-3 times)
    const tilesNeeded = 72;
    const symbolCount = foodSymbols.length;
    
    // Create array of symbols with proper pairs
    let symbolPool = [];
    
    // Each symbol should appear 2 or 4 times (even numbers for matching)
    for (let i = 0; i < symbolCount; i++) {
        // Add each symbol either 2 or 4 times
        const copies = i < 8 ? 4 : 2; // First 8 symbols appear 4 times, rest appear twice
        for (let j = 0; j < copies; j++) {
            symbolPool.push(foodSymbols[i]);
        }
    }
    
    // Shuffle the symbol pool
    for (let i = symbolPool.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbolPool[i], symbolPool[j]] = [symbolPool[j], symbolPool[i]];
    }
    
    // Generate pyramid positions (8 columns, variable rows per level)
    const positions = generatePyramidPositions(tilesNeeded);
    
    // Create tiles
    for (let i = 0; i < tilesNeeded; i++) {
        gameState.tiles.push({
            id: i,
            symbol: symbolPool[i],
            matched: false,
            selected: false,
            x: positions[i].x,
            y: positions[i].y,
            level: positions[i].level,
            free: false
        });
    }
}

// Generate pyramid-style positions with real stacking
function generatePyramidPositions(totalTiles) {
    const positions = [];
    const cols = 8;
    const tileWidth = 75; // Width + gap
    const tileHeight = 95; // Height + gap
    
    // Create 4 levels with increasing offsets to create real stacking
    const levelConfigs = [
        { rows: 3, yOffset: 0, xOffset: 15 }, // Bottom level - fully visible
        { rows: 3, yOffset: 25, xOffset: 10 }, // Second level - covers bottom
        { rows: 2, yOffset: 45, xOffset: 5 },  // Third level - covers second
        { rows: 1, yOffset: 65, xOffset: 0 }   // Top level - covers third
    ];
    
    let tileIndex = 0;
    
    // Generate from bottom to top (level 4 = bottom, level 1 = top)
    for (let level = 0; level < levelConfigs.length; level++) {
        const config = levelConfigs[level];
        const levelNumber = levelConfigs.length - level; // 4,3,2,1
        
        for (let row = 0; row < config.rows; row++) {
            // Calculate how many tiles in this row (pyramid shape)
            let tilesInRow = cols;
            if (level === 2) tilesInRow = 6; // Third level has fewer tiles
            if (level === 3) tilesInRow = 4; // Top level has even fewer
            
            const startCol = Math.floor((cols - tilesInRow) / 2);
            
            for (let col = 0; col < tilesInRow; col++) {
                if (tileIndex >= totalTiles) break;
                
                positions.push({
                    x: (startCol + col) * tileWidth + config.xOffset,
                    y: row * tileHeight + config.yOffset,
                    level: levelNumber
                });
                
                tileIndex++;
            }
            if (tileIndex >= totalTiles) break;
        }
        if (tileIndex >= totalTiles) break;
    }
    
    return positions;
}

// Real Mahjong free-tile detection
function updateFreeTiles() {
    const active = gameState.tiles.filter(t => !t.matched);
    
    // First, mark all active tiles as potentially free
    active.forEach(t => t.free = true);
    
    // Check each tile to see if it's covered by any tile above it
    active.forEach(tile => {
        active.forEach(other => {
            if (other.id === tile.id) return;
            
            // If other tile is on a higher level and overlaps this tile, this tile is blocked
            if (other.level > tile.level) {
                // Check if other tile overlaps this one
                const overlapX = Math.abs(tile.x - other.x) < 65; // 65px overlap threshold
                const overlapY = Math.abs(tile.y - other.y) < 80; // 80px overlap threshold
                
                if (overlapX && overlapY) {
                    tile.free = false;
                }
            }
        });
    });
    
    // After updating, check if game is unwinnable
    checkUnwinnable();
}

// Check if game is unwinnable and handle it
function checkUnwinnable() {
    const activeTiles = gameState.tiles.filter(t => !t.matched);
    const freeTiles = activeTiles.filter(t => t.free);
    
    // If no free tiles but game not finished, something's wrong
    if (freeTiles.length === 0 && activeTiles.length > 0) {
        setTimeout(() => {
            showProverbMessage("The pot is stuck! Auto-shuffling...");
            shuffleTiles(true); // Force shuffle without using a shuffle count
        }, 500);
        return;
    }
    
    // Check for available matches among free tiles
    const matches = findAvailableMatches();
    if (matches.length === 0 && activeTiles.length > 0) {
        // No matches available, but we have free tiles - unwinnable
        setTimeout(() => {
            if (gameState.shufflesRemaining > 0) {
                showProverbMessage("No matches available. Stirring the pot...");
                shuffleTiles(false);
            } else {
                showProverbMessage("Out of shuffles! Try a new game.");
            }
        }, 500);
    }
}

// Find available matches among FREE tiles only
function findAvailableMatches() {
    const matches = [];
    const freeTiles = gameState.tiles.filter(tile => !tile.matched && tile.free);
    
    for (let i = 0; i < freeTiles.length; i++) {
        for (let j = i + 1; j < freeTiles.length; j++) {
            if (freeTiles[i].symbol.id === freeTiles[j].symbol.id) {
                matches.push([freeTiles[i], freeTiles[j]]);
            }
        }
    }
    return matches;
}

// Render the game board
function renderBoard() {
    boardElement.innerHTML = '';
    
    // Sort tiles by level (higher levels rendered first so lower levels appear on top)
    const sortedTiles = [...gameState.tiles].sort((a, b) => b.level - a.level);
    
    sortedTiles.forEach(tile => {
        if (!tile.matched) {
            const tileElement = document.createElement('div');
            tileElement.className = `tile level-${tile.level}`;
            tileElement.dataset.id = tile.id;
            
            if (tile.selected) {
                tileElement.classList.add('selected');
            }
            
            if (!tile.free) {
                tileElement.classList.add('blocked');
            }
            
            tileElement.style.left = `${tile.x}px`;
            tileElement.style.top = `${tile.y}px`;
            
            const img = document.createElement('img');
            img.src = `images/${tile.symbol.imageFile}`;
            img.alt = tile.symbol.name;
            img.onerror = function() {
                this.src = 'https://via.placeholder.com/70x87/f9a826/1a2a3a?text=' + tile.symbol.name.charAt(0);
            };
            tileElement.appendChild(img);
            
            tileElement.addEventListener('click', (e) => {
                e.stopPropagation();
                selectTile(tile);
            });
            
            boardElement.appendChild(tileElement);
        }
    });
}

// Handle tile selection
function selectTile(tile) {
    // Can't select matched or blocked tiles
    if (tile.matched || !tile.free) return;
    
    gameState.lastMoveTime = new Date();
    gameState.proverbShown = false;
    
    // If no tile is selected, select this one
    if (!gameState.selectedTile) {
        // Deselect any previously selected tile
        gameState.tiles.forEach(t => t.selected = false);
        
        tile.selected = true;
        gameState.selectedTile = tile;
        showSymbolInfo(tile.symbol);
        renderBoard();
        return;
    }
    
    // If we have a selected tile and it's the same tile, deselect it
    if (gameState.selectedTile.id === tile.id) {
        gameState.selectedTile.selected = false;
        gameState.selectedTile = null;
        renderBoard();
        return;
    }
    
    // We have two different tiles - check if they match
    if (gameState.selectedTile.symbol.id === tile.symbol.id) {
        // Match found!
        gameState.selectedTile.matched = true;
        tile.matched = true;
        gameState.matches++;
        gameState.remaining -= 2;
        
        // Clear selection
        gameState.selectedTile.selected = false;
        gameState.selectedTile = null;
        
        // Update free tiles and render
        updateFreeTiles();
        renderBoard();
        updateStats();
        
        // Check if level complete
        if (gameState.remaining === 0) {
            endLevel();
        }
    } else {
        // Wrong match - show error animation
        showWrongMatch(tile);
        
        // Deselect previous tile
        gameState.selectedTile.selected = false;
        gameState.selectedTile = null;
        renderBoard();
    }
}

// Show wrong match animation
function showWrongMatch(tile) {
    const tileElements = document.querySelectorAll('.tile');
    tileElements.forEach(el => {
        if (el.dataset.id == tile.id || (gameState.selectedTile && el.dataset.id == gameState.selectedTile.id)) {
            el.classList.add('wrong-match');
            setTimeout(() => {
                el.classList.remove('wrong-match');
            }, 400);
        }
    });
}

// Start stuck detection
function startStuckDetection() {
    clearInterval(gameState.stuckTimer);
    gameState.stuckTimer = setInterval(() => {
        const now = new Date();
        const timeSinceLastMove = (now - gameState.lastMoveTime) / 1000;
        
        if (timeSinceLastMove > 15 && !gameState.proverbShown && gameState.remaining > 0) {
            showEncouragingProverb();
            gameState.proverbShown = true;
        }
    }, 1000);
}

// Show encouraging proverb when stuck
function showEncouragingProverb() {
    const proverb = proverbs[Math.floor(Math.random() * proverbs.length)];
    showProverbMessage(proverb);
}

// Show proverb message
function showProverbMessage(proverb) {
    // Remove any existing proverb messages
    const existing = document.querySelector('.proverb-message');
    if (existing) existing.remove();
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'proverb-message';
    messageDiv.textContent = proverb;
    
    document.body.appendChild(messageDiv);
    
    setTimeout(() => {
        if (document.body.contains(messageDiv)) {
            document.body.removeChild(messageDiv);
        }
    }, 4000);
}

// Show symbol information
function showSymbolInfo(symbol) {
    symbolNameElement.textContent = symbol.name;
    symbolMeaningElement.textContent = symbol.meaning;
}

// Update game statistics
function updateStats() {
    matchesElement.textContent = gameState.matches;
    remainingElement.textContent = gameState.remaining;
    levelElement.textContent = gameState.level;
    totalTilesElement.textContent = gameState.totalTiles;
}

// Update shuffle count display
function updateShuffleCount() {
    shuffleCountElement.textContent = `Shuffles remaining: ${gameState.shufflesRemaining}`;
}

// Start the game timer
function startTimer() {
    gameState.startTime = new Date();
    clearInterval(gameState.timerInterval);
    
    gameState.timerInterval = setInterval(() => {
        const now = new Date();
        gameState.elapsedTime = Math.floor((now - gameState.startTime) / 1000);
        const minutes = Math.floor(gameState.elapsedTime / 60);
        const seconds = gameState.elapsedTime % 60;
        timeElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }, 1000);
}

// Provide a hint
function provideHint() {
    const availableMatches = findAvailableMatches();
    if (availableMatches.length > 0) {
        const match = availableMatches[0];
        highlightTiles([match[0], match[1]]);
    } else {
        showProverbMessage(lossProverbs[Math.floor(Math.random() * lossProverbs.length)]);
    }
}

// Highlight tiles for hint
function highlightTiles(tiles) {
    // Temporarily select them
    tiles.forEach(tile => {
        tile.selected = true;
    });
    
    renderBoard();
    
    // Deselect after 2 seconds
    setTimeout(() => {
        tiles.forEach(tile => {
            tile.selected = false;
        });
        renderBoard();
    }, 2000);
}

// Shuffle tiles
function shuffleTiles(force = false) {
    // Check if we have shuffles left (unless forced)
    if (!force && gameState.shufflesRemaining <= 0) {
        showProverbMessage("No shuffles left! Try a new game.");
        return;
    }
    
    // Decrement shuffle count
    if (!force) {
        gameState.shufflesRemaining--;
        updateShuffleCount();
    }
    
    // Clear any selected tile
    if (gameState.selectedTile) {
        gameState.selectedTile.selected = false;
        gameState.selectedTile = null;
    }
    
    // Get unmatched tiles
    const unmatchedTiles = gameState.tiles.filter(tile => !tile.matched);
    
    // Shuffle their symbols
    const symbols = unmatchedTiles.map(tile => tile.symbol);
    for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
    }
    
    // Reassign symbols
    unmatchedTiles.forEach((tile, index) => {
        tile.symbol = symbols[index];
    });
    
    // Update free tiles and render
    updateFreeTiles();
    renderBoard();
    
    showProverbMessage("Ingredients stirred and rearranged!");
}

// Reset game to level 1
function resetGame() {
    clearInterval(gameState.timerInterval);
    clearInterval(gameState.stuckTimer);
    winMessage.classList.add('hidden');
    gameState.level = 1;
    initGame();
}

// Go to next level
function nextLevel() {
    clearInterval(gameState.timerInterval);
    clearInterval(gameState.stuckTimer);
    winMessage.classList.add('hidden');
    gameState.level++;
    initGame();
}

// End current level
function endLevel() {
    clearInterval(gameState.timerInterval);
    clearInterval(gameState.stuckTimer);
    
    // Show appropriate message
    if (gameState.level === 1) {
        winText.textContent = `üéâ Level ${gameState.level} Complete! Ready for more challenging layouts?`;
    } else {
        winText.textContent = `üéâ Level ${gameState.level} Complete! You're becoming a master chef!`;
    }
    
    winMessage.classList.remove('hidden');
}

// Event listeners
hintButton.addEventListener('click', provideHint);
shuffleButton.addEventListener('click', () => shuffleTiles(false));
resetButton.addEventListener('click', resetGame);
nextLevelButton.addEventListener('click', nextLevel);
playAgainButton.addEventListener('click', resetGame);

// Initialize when page loads
window.addEventListener('DOMContentLoaded', initGame);
</script>
</body>
</html>
